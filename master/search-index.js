var N = null;var searchIndex = {};
searchIndex["ihex"]={"doc":"The IHEX Library","items":[[0,"checksum","ihex","Function for computing IHEX checksum.",N,N],[5,"checksum","ihex::checksum","Computes the Intel HEX checksum of `data`. This is done by summing all the bytes `data and taking the two's complement of the least significant byte of the sum.",N,N],[0,"reader","ihex","Operations for parsing IHEX records and object files.",N,N],[3,"Reader","ihex::reader","",N,N],[4,"ReaderError","","",N,N],[13,"MissingStartCode","","The record provided does not begin with a ':'.",0,N],[13,"RecordTooShort","","The record provided is shorter than the smallest valid.",0,N],[13,"RecordTooLong","","The record provided exceeds the maximum size (255b payload).",0,N],[13,"RecordNotEvenLength","","The record is not an even number of bytes.",0,N],[13,"ContainsInvalidCharacters","","The record is not all hexadecimal characters.",0,N],[13,"ChecksumMismatch","","The checksum did not match.",0,N],[13,"PayloadLengthMismatch","","The record is not the length it claims.",0,N],[13,"UnsupportedRecordType","","The record type is not supported.",0,N],[13,"InvalidLengthForType","","The payload length does not match the record type.",0,N],[11,"eq","","",0,[[["self"],["readererror"]],["bool"]]],[11,"ne","","",0,[[["self"],["readererror"]],["bool"]]],[11,"clone","","",0,[[["self"]],["readererror"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"hash","","",0,N],[11,"description","","",0,[[["self"]],["str"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"new_stopping_after_error_and_eof","","Creates a new IHEX reader over `string` with the specified configuration parameters. If `stop_after_first_error` is `true` then the first error will make all subsequent calls to `next()` return `None`. If `stop_after_eof` is `true` then the first EoF record will make all subsequent calls to `next()` return `None`.",1,[[["str"],["bool"],["bool"]],["self"]]],[11,"new","","Creates a new IHEX reader over `string` with default configuration parameters.",1,[[["str"]],["self"]]],[11,"next","","Iterates over the lines of the IHEX object, skipping any empty ones, and returns the result of parsing that line.",1,[[["self"]],["option"]]],[0,"record","ihex","An Intel HEX record type.",N,N],[4,"Record","ihex::record","",N,N],[13,"Data","","Specifies a 16-bit offset address and up to 255 bytes of data. Availability: I8HEX, I16HEX and I32HEX.",2,N],[12,"offset","ihex::record::Record","The offset of the data record in memory.",2,N],[12,"value","","Up to 255 bytes of data to be written to memory.",2,N],[13,"EndOfFile","ihex::record","Indicates the end of the object file. Must occur exactly once per file, at the end. Availability: I8HEX, I16HEX and I32HEX.",2,N],[13,"ExtendedSegmentAddress","","Specifies bits 4-19 of the Segment Base Address (SBA) to address up to 1MiB. Availability: I16HEX.",2,N],[13,"StartSegmentAddress","","Specifies the 20-bit segment address via the CS and IP registers. Availability: I16HEX.",2,N],[12,"cs","ihex::record::Record","Value of the CS register.",2,N],[12,"ip","","Value of the IP register.",2,N],[13,"ExtendedLinearAddress","ihex::record","Specifies the upper 16 bits of a 32-bit linear address. The lower 16 bits are derived from the Data record load offset. Availability: I32HEX.",2,N],[13,"StartLinearAddress","","Specifies the execution start address for the object file. This is the 32-bit linear address for register EIP. Availability: I32HEX.",2,N],[0,"types","","",N,N],[17,"DATA","ihex::record::types","Type specifier for a Data record.",N,N],[17,"END_OF_FILE","","Type specifier for an End-Of-File record.",N,N],[17,"EXTENDED_SEGMENT_ADDRESS","","Type specifier for an Extended Segment Address record.",N,N],[17,"START_SEGMENT_ADDRESS","","Type specifier for a Start Segment Address record.",N,N],[17,"EXTENDED_LINEAR_ADDRESS","","Type specifier for an Extended Linear Address record.",N,N],[17,"START_LINEAR_ADDRESS","","Type specifier for a Start Linear Address record.",N,N],[11,"eq","ihex::record","",2,[[["self"],["record"]],["bool"]]],[11,"ne","","",2,[[["self"],["record"]],["bool"]]],[11,"clone","","",2,[[["self"]],["record"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"hash","","",2,N],[11,"record_type","","Returns the record type specifier corresponding to the receiver.",2,[[["self"]],["u8"]]],[0,"writer","ihex","Operations for generating IHEX records and object files.",N,N],[4,"WriterError","ihex::writer","",N,N],[13,"DataExceedsMaximumLength","","A record contains data too large to represent.",3,N],[13,"MissingEndOfFileRecord","","Object does not end in an EoF record.",3,N],[13,"MultipleEndOfFileRecords","","Object contains multiple EoF records.",3,N],[5,"create_object_file_representation","","Generates an Intel HEX object file representation of the `records` provided. It is the callers responsibility to ensure that no overlapping data ranges are defined within the object file. In addition, `records` must have contain 1 EoF record, and it must be the last element in `records`.",N,N],[11,"eq","","",3,[[["self"],["writererror"]],["bool"]]],[11,"ne","","",3,[[["self"],["writererror"]],["bool"]]],[11,"clone","","",3,[[["self"]],["writererror"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"hash","","",3,N],[11,"description","","",3,[[["self"]],["str"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"to_string","ihex::record","Returns the IHEX record representation of the receiver, or an error on failure.",2,[[["self"]],["result",["string","writererror"]]]],[11,"into_iter","ihex::reader","",1,[[["self"]],["i"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from_record_string","ihex::record","Constructs a new `Record` by parsing `string`.",2,[[["str"]],["result",["readererror"]]]],[11,"from_str","","",2,[[["str"]],["result"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","ihex::writer","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"to_string","","",3,[[["self"]],["string"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]]],"paths":[[4,"ReaderError"],[3,"Reader"],[4,"Record"],[4,"WriterError"]]};
initSearch(searchIndex);
