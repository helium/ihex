var searchIndex = {};
searchIndex["ihex"] = {"doc":"The IHEX Library","items":[[0,"checksum","ihex","Function for computing IHEX checksum.",null,null],[5,"checksum","ihex::checksum","Computes the Intel HEX checksum of `data`. This is done by summing all the bytes `data and taking the two's complement of the least significant byte of the sum.",null,null],[0,"reader","ihex","Operations for parsing IHEX records and object files.",null,null],[3,"Reader","ihex::reader","",null,null],[4,"ReaderError","","",null,null],[13,"MissingStartCode","","The record provided does not begin with a ':'.",0,null],[13,"RecordTooShort","","The record provided is shorter than the smallest valid.",0,null],[13,"RecordTooLong","","The record provided exceeds the maximum size (255b payload).",0,null],[13,"RecordNotEvenLength","","The record is not an even number of bytes.",0,null],[13,"ContainsInvalidCharacters","","The record is not all hexadecimal characters.",0,null],[13,"ChecksumMismatch","","The checksum did not match.",0,null],[13,"PayloadLengthMismatch","","The record is not the length it claims.",0,null],[13,"UnsupportedRecordType","","The record type is not supported.",0,null],[13,"InvalidLengthForType","","The payload length does not match the record type.",0,null],[11,"eq","","",0,{"i":[{"n":"self"},{"n":"readererror"}],"o":{"n":"bool"}}],[11,"ne","","",0,{"i":[{"n":"self"},{"n":"readererror"}],"o":{"n":"bool"}}],[11,"clone","","",0,{"i":[{"n":"self"}],"o":{"n":"readererror"}}],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"hash","","",0,null],[11,"description","","",0,{"i":[{"n":"self"}],"o":{"n":"str"}}],[11,"fmt","","",0,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_stopping_after_error_and_eof","","Creates a new IHEX reader over `string` with the specified configuration parameters. If `stop_after_first_error` is `true` then the first error will make all subsequent calls to `next()` return `None`. If `stop_after_eof` is `true` then the first EoF record will make all subsequent calls to `next()` return `None`.",1,{"i":[{"n":"str"},{"n":"bool"},{"n":"bool"}],"o":{"n":"self"}}],[11,"new","","Creates a new IHEX reader over `string` with default configuration parameters.",1,{"i":[{"n":"str"}],"o":{"n":"self"}}],[11,"next","","Iterates over the lines of the IHEX object, skipping any empty ones, and returns the result of parsing that line.",1,{"i":[{"n":"self"}],"o":{"n":"option"}}],[0,"record","ihex","An Intel HEX record type.",null,null],[4,"Record","ihex::record","",null,null],[13,"Data","","Specifies a 16-bit offset address and up to 255 bytes of data. Availability: I8HEX, I16HEX and I32HEX.",2,null],[12,"offset","ihex::record::Record","The offset of the data record in memory.",2,null],[12,"value","","Up to 255 bytes of data to be written to memory.",2,null],[13,"EndOfFile","ihex::record","Indicates the end of the object file. Must occur exactly once per file, at the end. Availability: I8HEX, I16HEX and I32HEX.",2,null],[13,"ExtendedSegmentAddress","","Specifies bits 4-19 of the Segment Base Address (SBA) to address up to 1MiB. Availability: I16HEX.",2,null],[13,"StartSegmentAddress","","Specifies the 20-bit segment address via the CS and IP registers. Availability: I16HEX.",2,null],[12,"cs","ihex::record::Record","Value of the CS register.",2,null],[12,"ip","","Value of the IP register.",2,null],[13,"ExtendedLinearAddress","ihex::record","Specifies the upper 16 bits of a 32-bit linear address. The lower 16 bits are derived from the Data record load offset. Availability: I32HEX.",2,null],[13,"StartLinearAddress","","Specifies the execution start address for the object file. This is the 32-bit linear address for register EIP. Availability: I32HEX.",2,null],[0,"types","","",null,null],[17,"DATA","ihex::record::types","Type specifier for a Data record.",null,null],[17,"END_OF_FILE","","Type specifier for an End-Of-File record.",null,null],[17,"EXTENDED_SEGMENT_ADDRESS","","Type specifier for an Extended Segment Address record.",null,null],[17,"START_SEGMENT_ADDRESS","","Type specifier for a Start Segment Address record.",null,null],[17,"EXTENDED_LINEAR_ADDRESS","","Type specifier for an Extended Linear Address record.",null,null],[17,"START_LINEAR_ADDRESS","","Type specifier for a Start Linear Address record.",null,null],[11,"eq","ihex::record","",2,{"i":[{"n":"self"},{"n":"record"}],"o":{"n":"bool"}}],[11,"ne","","",2,{"i":[{"n":"self"},{"n":"record"}],"o":{"n":"bool"}}],[11,"clone","","",2,{"i":[{"n":"self"}],"o":{"n":"record"}}],[11,"fmt","","",2,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"hash","","",2,null],[11,"record_type","","Returns the record type specifier corresponding to the receiver.",2,{"i":[{"n":"self"}],"o":{"n":"u8"}}],[0,"writer","ihex","Operations for generating IHEX records and object files.",null,null],[4,"WriterError","ihex::writer","",null,null],[13,"DataExceedsMaximumLength","","A record contains data too large to represent.",3,null],[13,"MissingEndOfFileRecord","","Object does not end in an EoF record.",3,null],[13,"MultipleEndOfFileRecords","","Object contains multiple EoF records.",3,null],[5,"create_object_file_representation","","Generates an Intel HEX object file representation of the `records` provided. It is the callers responsibility to ensure that no overlapping data ranges are defined within the object file. In addition, `records` must have contain 1 EoF record, and it must be the last element in `records`.",null,null],[11,"eq","","",3,{"i":[{"n":"self"},{"n":"writererror"}],"o":{"n":"bool"}}],[11,"ne","","",3,{"i":[{"n":"self"},{"n":"writererror"}],"o":{"n":"bool"}}],[11,"clone","","",3,{"i":[{"n":"self"}],"o":{"n":"writererror"}}],[11,"fmt","","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"hash","","",3,null],[11,"description","","",3,{"i":[{"n":"self"}],"o":{"n":"str"}}],[11,"fmt","","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"to_string","ihex::record","Returns the IHEX record representation of the receiver, or an error on failure.",2,{"i":[{"n":"self"}],"o":{"g":["string","writererror"],"n":"result"}}],[11,"from_record_string","","Constructs a new `Record` by parsing `string`.",2,{"i":[{"n":"str"}],"o":{"g":["readererror"],"n":"result"}}],[11,"from_str","","",2,{"i":[{"n":"str"}],"o":{"n":"result"}}]],"paths":[[4,"ReaderError"],[3,"Reader"],[4,"Record"],[4,"WriterError"]]};
initSearch(searchIndex);
